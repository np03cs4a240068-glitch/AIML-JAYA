# -*- coding: utf-8 -*-
"""wrksheet0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GvKaSo7qlG19U9Ktd--LthSycj36HbsD

Python version check

Data types in python
"""

age = 23 #int
pi = 3.14 #float
temperature = -5.5 #float
print("data type of variable age = ", type(age))
print("data type of variable pi = ", type(pi))
print("data type of variable temperature=", type(temperature))

"""Sequence - String"""

name = "miimimimi"
greeting = " hiiii"
address = "kathmandu eta uta"
print("data type of variable name= ", type(name))
print("data type of variable greeting= ", type(greeting))
print("data type of variable address = ", type(address))
#slice only one element
print("The first letter of the name is:", name[0])
print("The last letter of the name is:", name[-1])
#slice a range of elements
print("The second letter to the fourth of the name is:", name[1:4])
print("The first two letters of the name are:", name[:2])
print("Substring starting from the third letter is:", name[2:])

"""Sequences - List"""

list1 = [1, 2, 3, 4]
mixed_list = [12, "Hello", True]
#List is mutable
mixed_list[0] = False
mixed_list

"""Sequence - Tuple"""

colors = ('red', 'green', 'yellow', 'blue')
print("First element:", colors[0])
print("Last two elements:", colors [2:])
print("Middle two elements", colors[1:3])
#colors[0]='purple'
colors

"""Dictionaries"""

person = {'name': 'mimi', 'age':22, 'city':'nepal'}
print(f"Hello my name is {person['name']}. I am {person['age']} years old and I live in {person['city']}")
print("All keys:", list(person.keys()))
print("All values:", list(person.values()))

"""Set"""

unique_numbers={1,2,3,3,3,3,4,5}
print(unique_numbers)

"""Boolean"""

is_student = True
has_license = False
print("data type of the variable is_student = ", type(is_student))
print("data type od the variable has_license = ", type(has_license))

"""if-else statement"""

num = 10
if num>0:
  print("positve")
elif num == 0:
  print("zero")
else:
  print("non-positive")

"""Comparision operator"""

x = 5
y = 10
if x > 0 and y < 20:
  print (" duitai true")
if x > 0 or y > 20:
  print("Euta tru")
if not x == 0:
  print("x is not equal to zero")

"""Logical Operator"""

a = True
b = False
if a and b:
  print("duitai true")
else:
  print("euta tru a or b")
if a or b:
  print("atleast euta true")
else:
  print("duitai false")
if not a:
  print(" a is false")
else:
  print("a is true")

"""loops"""

fruits = ["apple", "banana", "cherry"]
for fruit in fruits:
  print(fruit)
#while loop
count = 0
while count < 5:
  print("Count is:", count)
  count +=1
#break
fruits = ["apple", "banana", "orange"]
print("loop 1 ")
for fruit in fruits:
  print(fruit)
  if fruit == "apple":
    break
  print("loop 2")
  for fruit in fruits:
    if fruit == "apple":
      continue
    else:
      print(fruit)

"""Funtion"""

def add_binary(a, b):
  '''
Returns the sum of two binary numbers in binary digts.
Parameters:
a(int) : a decimal integer
b(int) : another decimal integer
returns:
binary_sum (str): Binary string of the sum of a and b
'''
  binary_sum = bin(a+b)[2:]
  return binary_sum
print(add_binary)

"""Built in functions"""

print("Hello World")
length = len('hello')
data_type= type(42)
total = sum([1,2,3,4])
print(length)
print(data_type)
print(total)

"""Built-in methods"""

message = 'hello'.upper()
fruits = ['apple', 'banana']
fruits.append('cherry')
info = {'name': 'Alice', 'age': 25}
age = info.get('age')
print(message)
print(fruits)
print(age)

"""User-defined fxns"""

def temperature_converter():
  '''
  converts temperature between Celsius and Fahrenheit
  returns:
  float: the converted temperature value
  '''
  print("choose conversion type:")
  print("1 celsius to fahrenheit")
  print('2 fahrenheit to celsius')
  choice = input("Enter your choice 1 or 2:")
  if choice == '1':
    celsius = float(input("Enter temperature in celsius:"))
    fahrenheit = (celsius * 9/5) + 32
    print(f"{celsius} C is equal to {fahrenheit}F")
    return fahrenheit
  elif choice == 2:
    fahrenheit = float(input("Enter temperature in fahrenheit:"))
    celsius = (fahrenheit - 32) * 5/9
    print(f"{fahrenheit}F is equal to {celsius}C")
    return celsius
  else:
    print(" Invalid choice. Please enter 1 or 2")
    return None
temperature_converter()

"""Global variable"""

x = 10
def print_global():
  print(x)
print_global()

"""local variable"""

def print_local():
  y = 5
  print(y)
print_local()
print(y)

"""Accessing and modifying global variables in a fxn"""

x = 10
def modify_global():
  global x
  x = 20
modify_global()
print(x)

"""TO DO TASKS"""

time_data = [
    (3.5, 2.0, 7.0), (5.0, 1.5, 6.5), (2.5, 3.0, 8.0),
    (4.0, 2.0, 6.0), (1.5, 4.5, 9.0), (3.0, 2.5, 7.5),
    (5.5, 1.0, 6.0), (2.0, 3.5, 8.5), (4.5, 2.0, 7.0),
    (3.0, 3.0, 7.5), (6.0, 1.5, 6.0), (2.5, 4.0, 8.0),
    (4.0, 2.5, 7.0), (5.0, 2.0, 6.5), (3.5, 2.5, 7.0)
]
#task1
low=[]
moderate=[]
high=[]
for i in range(len(time_data)):
  study = time_data[i][0]
  if study<3.0:
    low.append((study))
  elif 3.0<=study<=5.0:
    moderate.append((study))
  else:
    high.append((study))
print(f'list of low study hrs',low)
print(f'list of moderate study hrs',moderate)
print(f'list of high study hrs',high)
#task2
num_low = len(low)
num_moderate = len(moderate)
num_high = len(high)
print(f'the number of students studying low is',num_low)
print(f'the number of students studying moderate time is',num_moderate)
print(f'the number of students studying high is',num_high)
#Task3
study_minutes=[]
for i in range (len(time_data)):
  study_minutes.append(time_data[i][0]*60)
print(f'the study hrs in minutes is',study_minutes)
#Task4
study_hours=[]
entertainment_hours=[]
sleep_hours=[]
for i in range(len(time_data)):
  study_hours.append(time_data[i][0])
  entertainment_hours.append(time_data[i][0])
  sleep_hours.append(time_data[i][0])
print(f'average hours spent studying', study_hours)
print(f'average hours spent on entertainment', entertainment_hours)
print(f'average hours spent sleeping', sleep_hours)
#Task 5
import matplotlib.pyplot as plt
x = time_data[0]
y = time_data[2]
plt.plot(x,y, color ='pink')
plt.xlabel('study hrs')
plt.ylabel('sleep hours')
plt.title('study hrs vs sleep hrs')
plt.show()

"""recursion for factorial"""

def factorial(n):

  '''
  Calculate the factorial of non-negative integer n.
  The factorial of a number n (denoted n !) is the product of all positive
  integers less than or equal to n.
  Specifically:
  - if n is 0, factorial is defined as 1 (base case).
  - for any positive integer n , the factorial is calculated recursively as n * (n-1)*
  (n-2) * ... * 1
  Args:
  n(int): a non-negative integer for which to calculate factorial
  Returns:
  int: the factorial of input num n
  Raises:
  ValueError: if n is negative integer, as factorial is only defined for non-negative
  integers
  '''
  if n == 0: #base case
    return 1
  else: #recursive case
    return n * factorial(n-1)
factorial(5)

"""Recursion Qusetions

Task 1
"""

def sum_nested_list(nested_list):
  '''
  Calculate the sum of all numbers in a nested list.
  This function takes a list that may contain integers and other nested lists.
  It recursively transverses the list and sums all the integers, no matter how deeply
  nested they are.
  Args:
      nested_list(list): A list that may contain integers or other list of integers.
  Returns:
      int: The total sum of all integers in the nested list, including those in sublists
  '''
  total = 0
  for element in nested_list:
    if isinstance(element, list): #check if element is a list
      total += sum_nested_list(element)
    else:
      total +=element #add number to the total
  return total
print(sum_nested_list([1, [2, [3, 4], 5], 6, [7, 8]]))

"""Task 2"""

def generate_permutations(s, i=0):
  if i == len(s):
    print(" ".join(s))
  for j in range(i, len(s)):
    string = [c for c in s]
    string[i], string[j] = string[j], string[i]
    generate_permutations(string, i+1)
generate_permutations("abc")

"""Task 3"""

def calculate_directory_size(directory):
  '''
  '''
  total_size=0;
  for name, value in directory.items():
    if isinstance(value, dict):
      total_size += calculate_directory_size(value)
    else:
      total_size += value
  return total_size


directory_structure = {
    'file1.txt': 200,
    'file2.txt': 300,
    'subdir1':{
        'file3.txt': 400,
        'file4.txt': 100,
    },
    'subdir2':{
        'subsubdir1':{
            'file5.txt':250
        },
        'file6.txt':150
    }
}
print(calculate_directory_size(directory_structure))

"""Fibonacci Sequence with memoization"""

def fibonacci(n, memo={}):

  '''
  Computes the nth Fibonacci number using memoization to optimize the recursive
  solution.
  Thisfunctionusesmemoization tostorepreviouslycomputedFibonaccinumbers,
  reducingredundantcalculationsandimprovingperformance.
  Parameters:
  n(int): TheindexintheFibonaccisequenceforwhichthevalueistobecomputed.
  Mustbeanon-negative integer.
  memo(dict,optional):AdictionaryusedtostorepreviouslycomputedFibonacci
  values.
  Itisinitializedasanemptydictionarybydefaultandisused
  duringtherecursivecallstoavoidrecalculatingresults.
  Returns:
  int:The nthFibonaccinumber.
  Example:
  >>>fibonacci(5)
  5
  >>>fibonacci(10)
  55
  TimeComplexity:-ThetimecomplexityisO(n)becauseeachFibonaccinumberiscomputedonlyonce.
  SpaceComplexity:-ThespacecomplexityisO(n) duetothememoizationdictionarystoringtheresults.
  '''
  if n in memo:
   return memo[n]
  if n <= 1:
    return n
  memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)
  return memo[n]
print(fibonacci(7))

"""Solving Fibonacci Sequence with Tabulation"""

def fibonacci(n):

  '''
  Computes thenthFibonaccinumberusingdynamicprogrammingtooptimizethesolution.
  Thisfunctionusesabottom-up dynamicprogrammingapproachtocalculatethenth
  Fibonacci
  number byiterativelybuilding upanarrayofFibonaccinumbersupton,thus
  eliminating redundantcalculationsandoptimizingperformance.
  Parameters:
  n(int): TheindexintheFibonaccisequenceforwhichthevalueistobecomputed.
  Mustbeanon-negative integer.
  Returns:
  int:The nthFibonaccinumber.
  Example:
  >>>fibonacci(5)
  5
  >>>fibonacci(10)
  55
  TimeComplexity:-ThetimecomplexityisO(n), asthefunctioniteratesthroughtherange2ton,
  calculating
  eachFibonaccinumberonce.
  SpaceComplexity:-ThespacecomplexityisO(n),duetothearrayusedtostoretheFibonaccinumbers
  up to n
  '''
  if n <= 1:
    return n
  dp = [0] * (n+1)
  dp[1] = 1
  for i in range(2, n+1):
    dp[i] = dp[i-1] + dp[i-2]
  return dp[n]
print(fibonacci(7))

"""Coin-change problem"""

def min_coins(coins, amount):
  '''
   Finds the minimum number of coins needed to make up a given amount using dynamic
  programming.
  This function solves the coin change problem by determining the fewest number of
  coins from a given set of coin denominations that sum up to a target amount. The
  solution uses dynamic programming(tabulation) to iteratively build up the minimum
  number of coins required for each amount.
  Parameters:
  coins (list of int): A list of coin denominations available for making change. Each
  coin denomination is a positive integer.
  amount (int): The target amount for which we need to find the minimum number of coins
  . It must be a non-negative integer.
  Returns:
  int: The minimum number of coins required to make the given amount.
  If it is not possible to make the amount with the given coins, returns-1.
  Example:
  >>> min_coins([1, 2, 5], 11)
  3
  >>> min_coins([2], 3)-1
  '''
  dp = [float('inf')] * (amount + 1)
  dp[0] = 0
  for coin in coins:
    for i in range(coin, amount + 1):
      dp[i] = min(dp[i], dp[i-coin] + 1)
  return dp[amount] if dp[amount] != float('inf') else -1
print(min_coins([1, 2, 5], 11))

"""Longest Common Sequence"""

def longest_common_subsequence(s1, s2):
  '''
  finds the length of the longest common subsequence using dynamic programming.

  this function determines the length of longest common subsequence using a bottom
  up dynamic programming approach. to fill a 2D table where each entry dp[i][j]
  represents the lcs length of substrings.

  Parameters:
        s1 (str): the first string.
        s2(str): the second string.

  Returns:
        int: the length of the longest common subsequence.
  '''
  dp = [[0 for j in range(len(s2) + 1)] for i in range(len(s1)+1)]
  for i in range(len(s1) -1, -1, -1):
    for j in range(len(s2) -1, -1, -1):
      if s1[i] == s2[j]:
        dp[i][j] = 1 + dp[i+1][j+1]
      else:
        dp[i][j] = max(dp[i+1][j], dp[i][j+1])
  return dp[0][0]

print(longest_common_subsequence("abcde", "ace"))

"""Knapsack Problem"""

def knapsack(weights, values, capacity):
  n = len(weights)
  dp = [[0]* (capacity + 1) for _ in range(n+1)]
  for i in range(1, n+1):
    w = weights[i-1]
    v = values[i-1]
    for j in range(1, capacity + 1):
      if w<=j:
        take = v + dp[i-1][j-w]
        not_take = dp[i-1][j]
        dp[i][j] = max(take, not_take)
      else:
        dp[i][j]= dp[i-1][j]
  return dp[n][capacity]
print(knapsack([1, 3, 4, 5], [1, 4, 5, 7], 7))